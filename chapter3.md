# 불변성

함수형 프로그래밍은 불변성을 굉장히 강조한다. 그리고 엘릭서도 불변성이 강조된다. 왜 그런걸까?

```
array = [1, 2, 3]
do_something(array)
print(array)
```

익히 알고 있는 언어에서 위 코드와 같은 프로그램을 짜고 항상 `[1, 2, 3]`이 될까? 라고 묻는 다면 No이다. 왜냐하면 do_something에서 array의 참조로 받아 수정하게 되면 다른 결과를 출력할 수 있기 때문이다.

이처럼 불변성이 지켜지지 않으면 가려진 작업으로 인해 예측하기 어렵고 문제가 생기면 발견하기도 쉽지 않다. 특히 다중 스레드 환경에서 위와 비슷한 문제가 발생하면 새로 짜는 것이 더 빠를지도 모른다.

> 가변성은 '현재 상태에 어떻게 도달했는지'라는 질문을 남긴다. - Jessica Kerr

이런 문제에서 함수형 언어 그리고 우리가 배우는 엘릭서는 **불변성**으로 해결한다. 복잡한 중첩 리스트부터 간단한 자료형까지 모두 똑같이 불변성을 지켜준다.

예를 들어 엘릭서는 [1, 2, 3]의 각 요소에 100을 더해야 한다면, 원본을 복사한 뒤 더해진 새로운 값을 담게 된다. 이 부분에서 많은 사람들이 값을 새롭게 복사하면 메모리가 2배로 필요하고, 복사하는 과정이 느릴 수 있는게 아닌가? 라는 의문을 가지게 된다. 하지만 현대 컴퓨팅 파워에서 이런 작업을 굉장히 작은 처리이며, 불변성을 지키지 못해 발생하는 버그와 그에 따른 디버깅 시간에 비하면 티끌만한 문제라고 할 수 있다. 만약 이런 부분이 문제가 된다면 극히 일부이며, 작은 부분을 위해 모든 영역을 가변성을 가져간다는 것은 다시금 생각해볼 문제이다.

그리고 불변성을 기반으로 하면 더 효율적인 경우도 있다.

```
list1 = [3, 2, 1]
list2 = [4 | list1]
```

list1에 4를 추가하는 코드다. list1은 불변성이 보장되기 때문에 변하지 않는다. 따라서 헤더에 4를 추가한 list1을 list2에 넣게 되면 효율적으로 추가가 가능하다. 이것은 [3, 2, 1]이 변하지 않는다는 불변성이 지켜지기 때문에 가능한 연산이다.

하지만 여전히 메모리를 두배로 사용하는 문제점은 남아있다. 하지만 엘릭서는 이 문제도 우아하게 해결한다. 엘릭서는 많은 프로세스를 사용하는 코드를 작성할 수 있다. 따라서 GC는 분산된 프로세스 내에 작은 메모리들을 빠르게 처리하게 된다. 

## 불변 데이터를 이용해 코딩하기

함수형 언어에서는 데이터는 항상 변형한다. 여기서 '변형'에 주목해야하는데, 객체지향에서의 변경이 아닌 점이다.

```
name = "elixir"
cap_name = String.capitalize name
```

객체지향에 익숙한 사용자라면 `name.capitalize`가 좀 더 익숙할 것 이다. 하지만 이런 코드는 내부 상태가 변경된 것인지, 복사본을 반환하는지 애매한 점이 있다. 특정 언어는 `sort`, `sorted`로 구분하여 내부 상태의 변경과 복사본 반환을 구분하여 사용하는데, 비영어권 사용자들은 그 의미가 쉽게 받아들여지지 않는다.

함수형은 이런 애매한 부분이 없이 **불변성**과 **데이터의 변형**을 기반으로 직관적으로 복사본에 의미를 받아들이게 된다.
